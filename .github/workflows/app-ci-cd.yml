name: Application CI/CD

on:
  # trigger when branch is created
  create:

  # Triggers the workflow on push or pull request events but only for the master or release branch
  push:
    paths-ignore:
      - docs/**
      - .idea/**
      - .run/**
      - .vscode/**
      - .github/workflows/__infra-*
      - .github/workflows/infra-*
      - .github/workflows/__github-*
      - .github/workflows/github-*
      - .github/workflows/__okta-*
      - .github/workflows/okta-*
      - tools/db-scripts/**
      - tools/dev-scripts/**
      - tools/infrastructure/**
      - '!tools/infrastructure/get-product-conventions.ps1'
      - '!tools/infrastructure/ps-functions/Get-ResourceConvention.ps1'
      - tools/okta/**
    branches:
      - master
      - release/**
  pull_request:
    paths-ignore:
      - docs/**
      - .idea/**
      - .run/**
      - .vscode/**
      - .github/workflows/__infra-*
      - .github/workflows/infra-*
      - .github/workflows/__github-*
      - .github/workflows/github-*
      - .github/workflows/__okta-*
      - .github/workflows/okta-*
      - tools/db-scripts/**
      - tools/dev-scripts/**
      - tools/infrastructure/**
      - tools/okta/**
    branches:
      - master
      - release/**
    
  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

    
permissions:
  actions: read
  contents: read
  
jobs:
  
  globalvars:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4 # need to checkout so that custom action is available!
      - uses: ./.github/actions/set-global-build-vars
        id: vars
        with:
          git-tag-suffix: app
    outputs:
      buildNumber: ${{ steps.vars.outputs.buildNumber }}
      buildTag: ${{ steps.vars.outputs.buildTag }}
      buildType: ${{ steps.vars.outputs.buildType }}
      buildVersion: ${{ steps.vars.outputs.buildVersion }}
      createRelease: ${{ steps.vars.outputs.createRelease }}
      gitTag: ${{ steps.vars.outputs.gitTag }}
      runBuild: ${{ steps.vars.outputs.runBuild }}
      acrEnvironment: ${{ steps.vars.outputs.acrEnvironment }}
      acrName: ${{ steps.vars.outputs.acrName }}
  
  build:
    needs: globalvars
    if: needs.globalvars.outputs.runBuild == 'true'
    uses: ./.github/workflows/__app-ci.yml
    with:
      build-tag: ${{ needs.globalvars.outputs.buildTag }}
      build-version: ${{ needs.globalvars.outputs.buildVersion }}
      environment-name: ${{ needs.globalvars.outputs.acrEnvironment }}
      azure-container-registry: ${{ needs.globalvars.outputs.acrName }}
      create-release: ${{ fromJSON(needs.globalvars.outputs.createRelease) }}
    secrets: inherit
    permissions:
      actions: read
      contents: write
      id-token: write
      issues: read
      checks: write
      pull-requests: write
      
  auto_approve-deploy-qa:
    runs-on: ubuntu-latest
    needs: [globalvars, build]
    if: needs.globalvars.outputs.createRelease == 'true' && needs.globalvars.outputs.buildType == 'release'
    steps:
      - name: Sleep for 30 seconds # wait for jobs that require approval to start and enter pending state
        run: sleep 30s
      - name: Auto Approve Deployments qa
        uses: activescott/automate-environment-deployment-approval@10179fc61443cb28b95e807814d9dfce60a9e230 # <- v1.1.0
        with:
          github_token: ${{ secrets.AUTO_APPROVE_DEPLOYMENTS_TOKEN }}
          environment_allow_list: qa
          run_id_allow_list: ${{ github.run_id }} # only approve the current run of THIS workflow only

  deploy-dev:
    needs: [globalvars, build]
    if: needs.globalvars.outputs.createRelease == 'true' && needs.globalvars.outputs.buildType == 'ci'
    uses: ./.github/workflows/__app-deploy.yml
    with:
      artifact-source: workflow
      docker-image-tag: ${{ needs.globalvars.outputs.buildTag }}
      docker-registry: ${{ needs.globalvars.outputs.acrName }}
      environment-name: dev
      git-tag: ${{ needs.globalvars.outputs.gitTag }}
    secrets: inherit
    permissions:
      actions: read
      contents: read
      id-token: write
      
  release-dev:
    needs: [globalvars, deploy-dev]
    uses: ./.github/workflows/__app-create-release.yml
    with:
      git-tag: ${{ needs.globalvars.outputs.gitTag }}
    permissions:
      actions: read
      contents: write

  deploy-qa:
    needs: [globalvars, build]
    # IMPORTANT: we do WANT to allow builds for master branch and manually triggered runs to be *available* to deploy to QA
    # Therefore we WILL deploy to qa automatically BUT we assume that the qa github environment is set up to require manual
    # approval before the job runs. For builds from release branch, our workflow job above 'auto_approve-deploy-qa', will
    # approve this gated deployment rather than having to wait on someone to remember to have to do this.
    # In essence, with our setup we get:
    # 1. commits to the release branch deploying automatically to QA (ie continuous deployment (CD) to qa)
    # 2. commits to the master branch and manually triggered runs, deploying automatically to dev (ie continuous deployment (CD) to dev)
    # 3. commits to the master branch and manually triggered runs, being available to deploy to QA via a manual approval via the github UI
    if: needs.globalvars.outputs.createRelease == 'true'
    uses: ./.github/workflows/__app-deploy.yml
    with:
      artifact-source: workflow
      # we require cancellation of pending workflow runs to allow the auto_approve-deploy-qa job to work. without this,
      # if there is a pending deployment to qa, the auto approval will not happen as the deployment cannot be approved until 
      # the pending one is dealt with
      cancel-in-progress: true
      docker-image-tag: ${{ needs.globalvars.outputs.buildTag }}
      docker-registry: ${{ needs.globalvars.outputs.acrName }}
      environment-name: qa
      git-tag: ${{ needs.globalvars.outputs.gitTag }}
    secrets: inherit
    permissions:
      actions: read
      contents: read
      id-token: write
  
  release-qa:
    needs: [globalvars, deploy-qa]
    # we could be arriving here after deploying master branch to dev. In that case we've already created the github release
    # for the workflow, so make sure only to create the github release when building from the release branch
    if: needs.globalvars.outputs.buildType == 'release'
    uses: ./.github/workflows/__app-create-release.yml
    with:
      git-tag: ${{ needs.globalvars.outputs.gitTag }}
    permissions:
      actions: read
      contents: write